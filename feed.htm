<html><head><meta http-equiv=Content-Type content='text/html; charset=utf-8'></head>
<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>petterObam</title>
    <link>http://www.oyjie.cn</link>
    <description>一段代码，一个故事</description>
    <language>zh-CN</language>
    <item>
      <title>#2018-02-21# 数据库面向对象封装[干货]</title>
      <link>http://www.oyjie.cn/article/9</link>
      <content:encoded>&lt;h2&gt;前情提要&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    大部分应用都是由程序和数据两个部分构成的，而数据除了少部分是通过配置等写死的外，大部分总是都是通过特殊格式的文件（xml、access或sqlite）或独立的系统（oracle、mysql、sql server或elasticsearch、mongodb等）承载的。因此，程序和数据的无缝联结，对应用的扩展和迭代尤为重要，对程序的高可用和可维护性非常关键。故今天需要讨论的是对数据，主要是对数据库的封装，而习惯OOP的个人，则是对数据库的面向对象的封装。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;我的思路&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    众所周知，我们与数据库沟通用的是数据库的语言SQL，就像我们编程的语言是Java、C#、JavaScript一样，不同的语言是不能直接沟通的，需要一个翻译层，所以这一层就是面向数据库封装，而这一层jdk里面早就实现了（jdbc），本文个人以最接近的实际数据库的文件数据库sqlite（org.sqlite.JDBC）来做代码实验。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;!-- maven:sqlite数据库操作 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.xerial&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sqlite-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${sqlite.version}&amp;lt;/version&amp;gt; 
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;#java所用的sql语言也是通用的sql预处理语言，通过占位符（?）接收各种类型的变量，可以说即安全又优美。
[oracle语法]：select * from table where 1=1 and column1=? and column2&amp;gt;? or column3 like '%'||?||'%' 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    当前的很多框架已经完美的封装了数据库，mybatis、hibernate这些对数据库的语言做了非常灵活的处理，也有一套各自自己的语法。但是，个人认为xml文件还是属于配置文件，如果能实现零配置的面向对象封装就好了。面向对象封装需要达到的程度就是通过一个对象的信息可以直接自动的产生数据库相关的sql，然后将对象的变量属性值对应sql的占位符，并且在基类上实现基本的功能。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;public abstract class SqliteBaseDao&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    public int insert(String sql){...}
    public int update(String sql){...}
    public int delete(String sql){...}
    public List&amp;lt;T&amp;gt; query(String sql){...}
    // 通过对象信息实现增删查改
    public int insert(T entity){...}
    public int update(T entity){...}
    public int delete(T entity){...}
    public int deleteById(Object id){...}
    public List&amp;lt;T&amp;gt; query(T entity){...}
    public T queryById(Object id){...}
    // 自定义SQL的实现，模仿mybatis的xml动态SQL，但是不是用xml文件的方式
    public List&amp;lt;T&amp;gt; excuteQuery(T entity) {...}
    public List&amp;lt;T&amp;gt; excuteQuery(Object... params) {...}
    public int excute(T entity) {...}
    public int excute(Object... params) {...}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;一个类信息收集器&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    想要做到面向对象的数据库封装，就要把数据的最小单元和程序的最小单元关联起来，这两个单元都是独立的整体，再分割就会出现信息失真或不对称的情况。数据的最小单元就是表的单行记录，程序最小单元是实体类的单个对象，但是数据不一定有，对象需要实例化，需要运行起来才能提供信息。因此，这个最小单元要静态化，那就是数据库的表结构和实体类的信息关联起来。

    表结构能提供的信息有表名、表列名、列属性（类型、是否为空、默认值），实体类能提供的信息有类名、类变量名、类变量名属性（变量类型），似乎大部分都能对应上，但是属性部分还不能对应上，比如是否为空、默认值，而且为了良好的Java编码规范，有些东西和数据库的一些信息是不能完全对应的，比如通常java的命名规范一般不允许带下划线，而是用驼峰命名，而数据库的表和字段确经常用下划线分割单词（主要由于很多数据库不区分表名和字段名的大小写，甚至有些数据库不支持表名和字段名的大写）这就非常尴尬了，所以，这种差异化的对应就需要配置。并且，为了增加扩展性，程序单元的实体类的信息往往要比数据单元的表结构信息多一些，比如可能会有非表字段的属性（占位符中非表字段的传入属性和结果集中非表字段的接收属性），

    ibatis、hibernate就用到了这些，但是用的是xml文件，而且一旦配置出错还非常容易影响编译，并且不容易定位问题。mybatis+spring的xml和java注解让系统变得非常灵活，但是依然不能彻底的去掉xml文件，而且xml中如果出现一个小小的分号或空格都有可能引发问题，要是只用java注解就能解决掉的话就完美了。

    综上，想要实现这些适配，需要几个基础的注解：表名注解、主键注解、表字段注解、非表字段标识注解、自定义SQL注解（多种）。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * 表名注解类
 * @author 欧阳洁
 * @create 2017-09-30 11:16
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.TYPE})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface SqliteTable {
    String name() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * Sqlite的ID注解类
 * @author 欧阳洁
 * @create 2017-09-30 11:20
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface SqliteID {
    /* 主键列名，默认空*/
    String name() default &amp;quot;&amp;quot;;
    /* 主键默认类型，默认integer类型 */
    String type() default &amp;quot;integer&amp;quot;;
    /* 主键是否自增长，默认是true */
    boolean autoincrement() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * Sqlite的表(列）字段注解类
 * @author 欧阳洁
 * @create 2017-09-30 11:20
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface SqliteColumn {
    /* 列名，默认空 */
    String name() default &amp;quot;&amp;quot;;
    /* 主键默认类型，默认最大20位长度的字符串 */
    String type() default &amp;quot;char(20)&amp;quot;;
    /* 主键是否自增长，默认是true */
    boolean notNull() default true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * 非表字段注解
 * @author 欧阳洁
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface SqliteTransient {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * 自定义SQL注解类
 * @author 欧阳洁
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.METHOD})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface SqliteSql {
    /* 自定义的Sql语句，带占位符的Sql */
    String sql();
    /* 占位符顺序对应的参数顺序，默认不带参数 */
    String[] params() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    在上述的这些注解中，主键注解、表字段注解、非表字段标识注解其实都可以归为表字段注解，只要稍微添加某些属性就可以实现其他两个注解的功能，但是为了使用的方便性和程序的可读性，我牺牲了顶层代码的简易性，对这三个注解都做了区分和处理。而自定义SQL注解应该类似于mybatis里面的xml标签，@SqliteSql这个注解类只是实现了基本的（select、insert、delete、update）标签，搭配SqliteBaseDao里面的基本方法就可以轻松实现简单的mapper功能，而那些复杂的if else、choose when标签则需要例外些其他的辅助标签搭配使用，比如需求最多的动态where，可以定义类似于@SqliteSqlWhereIf，这样就可以简单的实现if标签，并且通过testId和parentTestId还可以实现if标签的嵌套功能，然后利用java8的新特性@Repeatable实现重复注解，或者直接定义一个集合注解（这个看着不是特别美观）就可轻松的实现判断条件非嵌套动态生成各种sql。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;public abstract class SqliteBaseDao&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    ...
    // 自定义SQL的实现，模仿mybatis的xml动态SQL，但是不是用xml文件的方式
    public List&amp;lt;T&amp;gt; excuteQuery(T entity) {...}  //对应select标签
    public List&amp;lt;T&amp;gt; excuteQuery(Object... params) {...}  //对应select标签
    public int excute(T entity) {...}   //对应insert、update、delete标签
    public int excute(Object... params) {...}   //对应insert、update、delete标签
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * 自定义SQL注解类，实现SqliteSqlWhereIf的重复注解
 * @author 欧阳洁
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.METHOD})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface SqliteSqlWhereIfs {
    SqliteSqlWhereIf[] value();
}
/**
 * 自定义SQL注解类，条件判断注解，用于生成动态SQL
 * @author 欧阳洁
 */
@java.lang.annotation.Target(value = {java.lang.annotation.ElementType.METHOD})
@java.lang.annotation.Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
@java.lang.annotation.Repeatable(SqliteSqlWhereIfs.class)
public @interface SqliteSqlWhereIf {
    /* 判断条件标识ID */
    int testId();
    /* 所属层级，默认0，最外层 */
    int parentTestId() default 0;
    /* 判断条件类型，==、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、eq、ne */
    String testType() default &amp;quot;eq&amp;quot;;
    /* 判断字段名 */
    String testName();
    /* 符合条件的值 */
    String[] testTrueValue();
    /* 符合条件对应的动态SQL */
    String[] testTrueSql() default &amp;quot;&amp;quot;;
    /* 占位符顺序对应的参数顺序，默认不带参数 */
    String[] params() default &amp;quot;&amp;quot;;
}

例如：
@SqliteSql(sql = &amp;quot;select * from this.tableName where 1=1&amp;quot;)
@SqliteSqlWhereIf(testId=1,testType=&amp;quot;eq&amp;quot;,testName=&amp;quot;searchType&amp;quot;,testTrueValue={&amp;quot;2&amp;quot;},testTrueSql=&amp;quot; and create_time&amp;gt;datetime('now') &amp;quot;)
@SqliteSqlWhereIf(testId=2,testType=&amp;quot;ne&amp;quot;,testName=&amp;quot;name&amp;quot;,testTrueValue={&amp;quot;&amp;quot;},testTrueSql=&amp;quot; and name like '%'||?||'%' &amp;quot;,parentTestId=1,params={&amp;quot;name&amp;quot;})
@SqliteSqlWhereIf(testId=3,testType=&amp;quot;eq&amp;quot;,testName=&amp;quot;author&amp;quot;,testTrueValue={&amp;quot;&amp;quot;},testTrueSql=&amp;quot; and author=? or name=? &amp;quot;,parentTestId=1,params={&amp;quot;author&amp;quot;,&amp;quot;author&amp;quot;})
public List&amp;lt;XXX&amp;gt; method1(XXX entity){ return super.excuteQuery(entity); }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    于是，类信息收集器能做成静态的吗，不能。因为每个表的信息不同，就会对应不同的类信息，如果我们做成静态的，那么就会产生很多无意义的重复代码，我们要用对象存储他，并且是一个表用一个对象去存储。这样，我们就可以准确定义一个类信息收集器的收集内容了，如下所示：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * 实体类T的信息收集器
 * Sqlite的Sql语句生成器
 * @author 欧阳洁
 * @create 2017-09-30 10:56
 */
public class SqliteSqlHelper&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    private Class&amp;lt;T&amp;gt; targetClass;//实体类
    private String tableName;//表名
    private String idName;//主键名
    private Field idField;//主键变量属性
    List&amp;lt;Field&amp;gt; columnFields;//表列名对应的变量属性集合
    Map&amp;lt;String, String&amp;gt; columnMap;//表列名和字段映射map

    /**
     * 构造函数
     * @param targetClass
     */
    public SqliteSqlHelper(Class&amp;lt;T&amp;gt; targetClass) {
        this.tableName = this.getTableNameForClass(targetClass);
        this.targetClass = targetClass;
        this.columnFields = new Vector&amp;lt;Field&amp;gt;();
        this.columnMap = new HashMap&amp;lt;String, String&amp;gt;();
        this.getColumnFields();//表列名对应的变量属性相关信息，包括表列名和字段映射
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;一个SQL生成器&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    和数据库沟通就需要使用相应的SQL语言，而通用的关系型数据库（oracle、mysql、sql server等），甚至是非关系型的数据库NOSQL（elasticsearch、mongodb等），绝大部分交互无非就是增删查改，而SQL的增删查改语言几乎是通用的。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;# 建表
    create table t_test_table(
        id integer primary key autoincrement not null,
        name char(100) not null,
        author char(100) not null,
        article text,
        create_time char(20) not null
    );
# 新增
    insert into t_test_table(name,author, article,create_time)
        values (&amp;quot;test11&amp;quot;,&amp;quot;petter&amp;quot;,&amp;quot;article1&amp;quot;,&amp;quot;2017-09-29 17:01:22&amp;quot;);
# 查询
    select * from t_test_table;
    select * from t_test_table where id=1;
# 修改
    update t_test_table
        set name = &amp;quot;test11_修改&amp;quot;, article = &amp;quot;article1_修改&amp;quot;, create_time = &amp;quot;2017-09-29 17:01:27&amp;quot;
            where id=1;
# 删除
    delete from t_test_table where id = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    这里多了个建表SQL，这里是为了实现自动化部署数据库用的，相当于程序驱动数据，让更多主动层面转移到程序代码这一层。当我们为我们的业务新增一个数据实体时候，程序就能自动的去生成规范的数据库，免去了繁琐的手动创建以及容易弄错的字段类型方面的细节，如果封装的好的话，迭代更新就能免去SQL脚本了。扩展一下的话，在表名注解里面添加数据库的链接属性还可以实现平滑分库的功能（这个可以，对于sqlite这种小型数据库，如果能实现分库的话，那就不再是小型数据库了，当然本文的例子还是以单数据库为例）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且建表的sql生成比较简单，只要单独的根据实体类的信息就能直接生成，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;# SqliteSqlHelper.java
public class SqliteSqlHelper&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    /**
     * 创建创建表的sql语句
     */
    public String createTableSql() {
        StringBuffer sql = new StringBuffer(&amp;quot;create table if not exists &amp;quot;);
        sql.append(this.tableName).append(&amp;quot;(&amp;quot;);
        boolean useCumma = false;
        for (Field field : this.columnFields) {
            if (useCumma) {
                sql.append(&amp;quot;,&amp;quot;);//第一次不用逗号
            }else{
                useCumma = true;
            }
            
            String columnName = field.getName();
            String columnType = &amp;quot;char(20)&amp;quot;;
            String notNull = &amp;quot;&amp;quot;;
            SqliteID id = field.getAnnotation(SqliteID.class);
            if (id != null) {
                columnName = SqliteUtils.isBlank(id.name()) ? field.getName() : id.name();
                columnType = id.type();
                //主键默认不为空，如果自增长默认自增长
                notNull = id.autoincrement() ? &amp;quot; primary key autoincrement not null&amp;quot; : &amp;quot; primary key not null&amp;quot;;
            } else {
                SqliteColumn column = field.getAnnotation(SqliteColumn.class);
                if (null != column) {
                    columnName = SqliteUtils.isBlank(column.name()) ? field.getName() : column.name();
                    columnType = column.type();
                    notNull = column.notNull() ? &amp;quot; not null&amp;quot; : &amp;quot;&amp;quot;;
                }
            }
            sql.append(columnName.toLowerCase()).append(&amp;quot; &amp;quot;).append(columnType.toLowerCase()).append(&amp;quot; &amp;quot;).append(notNull);
        }
        sql.append(&amp;quot;)&amp;quot;);
        return sql.toString();
    }
    ...
}

# SqliteBaseDao.java
public abstract class SqliteBaseDao&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    private String tableName;
    private Class entityClazz;
    private SqliteSqlHelper sqlHelper;

    public SqliteBaseDao(Class&amp;lt;T&amp;gt; entityClass) {
        this.sqlHelper = new SqliteSqlHelper(entityClass);
        this.tableName = this.sqlHelper.getTableName();
        this.entityClazz = entityClass;
        //调用该方法就能在使用时检查和创建表，可以通过配置信息判断是否执行，达到开关控制的效果
        this.existOrCreateTable();
    }
    /**
     * 检查表是否存在，不存在则创建
     */
    public void existOrCreateTable() {
        String sql = this.sqlHelper.createTableSql();
        SqliteHelper.execute(sql);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    同理，增删查改，也是通过类的信息进行sql的组装，但是却依赖调用入参实现动态sql生成。就以查询为例，默认的动态sql生成，基于传入的实体类对象里面的值，一般为空的不做处理，不为空的条件用and做连接起来形成动态的查询SQL。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;# SqliteSqlHelper.java
public class SqliteSqlHelper&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    /**
     * 创建查询语句
     */
    public void createSelect(T target) {
        List&amp;lt;Object&amp;gt; param = new Vector&amp;lt;Object&amp;gt;();
        StringBuffer sqlBuffer = new StringBuffer();
        sqlBuffer.append(&amp;quot;SELECT * FROM &amp;quot;).append(this.tableName);
        finishWhereOfAnd(sqlBuffer, param, target);
    
        target.setCurrentSql(sqlBuffer.toString());
        target.setCurrentParam(param);
    }
    /**
     * 补全用and连接的sql语句
     * @param sqlBuffer
     * @param param
     * @param target
     */
    private void finishWhereOfAnd(StringBuffer sqlBuffer, List&amp;lt;Object&amp;gt; param, T target) {
        sqlBuffer.append(&amp;quot; WHERE 1=1 &amp;quot;);
        Object idValue = null;
        if (null != this.idField) {
            idValue = readField(this.idField, target);
        }
        if (idValue != null) {
            sqlBuffer.append(&amp;quot; and &amp;quot;).append(this.idName).append(&amp;quot;=?&amp;quot;);
            param.add(idValue);
        } else {
            for (Field field : this.columnFields) {
                if (!Modifier.isStatic(field.getModifiers())) {
                    Object currentValue = readField(field, target);
                    if (null != currentValue &amp;amp;&amp;amp; !SqliteUtils.equals(this.idName, field.getName())) {
                        String columnName = field.getName();
                        SqliteColumn sqliteColumn = field.getAnnotation(SqliteColumn.class);
                        if (null != sqliteColumn) {
                            columnName = SqliteUtils.isBlank(sqliteColumn.name()) ? field.getName() : sqliteColumn.name();
                        }
                        sqlBuffer.append(&amp;quot; and &amp;quot;).append(columnName.toLowerCase()).append(&amp;quot;=?&amp;quot;);
                        param.add(currentValue);
                    }
                }
            }
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    对于自定义SQL的获取和动态组装生成，它相对其他类的SQL就要复杂一些，因为这个注解不是在实体类中，而是在Dao类中，而且是一种用于方法的注解。想要知道如何获取这类注解的信息，就需要了解java程序的一些运行原理。
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;线程栈区的方法栈：简而言之，就是每个运行中的程序会有一个线程，而调用的方法、调用方法调用的方法、调用方法调用的方法调用的方法...他们会形成该线程的方法栈，进行中的方法都会放入这个栈中，这样我们就可以在运行时候获取到对应的方法了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;    然而，我们要使得注解和编码更加简洁易懂，我们需要把这部分获取的代码放到Dao类继承的基类（SqliteBaseDao）中，通过基类获取子类的某个方法的注解信息。虽然基类获取子类方法信息与常规程序设计有较大差异，但是只有这样才能实现优美的封装。下面为自定义查询部分代码（增删改同理）：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;# SqliteSqlHelper.java
public class SqliteSqlHelper&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    /**
     * 创建自定义查询语句
     */
    public void convertSelfSql(StackTraceElement daoMethodInfo, T target) {
        if (null == daoMethodInfo) {//为空用默认的查询语句
            createSelect(target);
            return;
        }
        Method method = getMethod(daoMethodInfo.getClassName(), daoMethodInfo.getMethodName(), target.getClass());
        if (null == method) {//为空用默认的查询语句
            createSelect(target);
            return;
        }
        SqliteSql sqliteSql = method.getAnnotation(SqliteSql.class);
        if (null != sqliteSql) {
            List&amp;lt;Object&amp;gt; param = new Vector&amp;lt;Object&amp;gt;();
            String[] paramNameArr = sqliteSql.params();
            if (null != paramNameArr &amp;amp;&amp;amp; paramNameArr.length &amp;gt; 0) {
                Field[] fieldArray = this.targetClass.getDeclaredFields();
                for (String paramName : paramNameArr) {
                    Object value = null;
                    for (Field field : fieldArray) {
                        if (paramName.equalsIgnoreCase(field.getName())) {
                            value = readField(field, target);
                            break;
                        }
                    }
                    param.add(value);
                }

            }
            String sql = SqliteUtils.replace(sqliteSql.sql(), &amp;quot;this.tableName&amp;quot;, this.tableName);
            //TODO 此处可以读取自定义SQL的辅助注解，像上面提到的SqliteSqlWhereIf注解，实现动态SQL
            target.setCurrentSql(sql);
            target.setCurrentParam(param);
        }
    }
    /**
     * 创建自定义查询语句，参数随机
     */
    public String convertSelfSql(StackTraceElement daoMethodInfo, Object... params) {
        if (null == daoMethodInfo) {//为空不做处理
            System.out.println(&amp;quot;未获取到自定义的语句！&amp;quot;);
            return null;
        }
        Class&amp;lt;?&amp;gt;[] classArr = null;
        if (null != params &amp;amp;&amp;amp; params.length &amp;gt; 0) {
            classArr = new Class&amp;lt;?&amp;gt;[params.length];
            for (int i = 0; i &amp;lt; params.length; i++) {
                classArr[i] = params[i].getClass();
            }
        }
        Method method = getMethod(daoMethodInfo.getClassName(), daoMethodInfo.getMethodName(), classArr);
        if (null == method) {//为空不做处理
            System.out.println(&amp;quot;未获取到自定义的语句！&amp;quot;);
            return null;
        }
        SqliteSql sqliteSql = method.getAnnotation(SqliteSql.class);
        //TODO 此处可以读取自定义SQL的辅助注解，像上面提到的SqliteSqlWhereIf注解，实现动态SQL
        String sql = SqliteUtils.replace(sqliteSql.sql(), &amp;quot;this.tableName&amp;quot;, this.tableName);
        return sql;
    }
    ...
}

# SqliteBaseDao.java
public abstract class SqliteBaseDao&amp;lt;T extends SqliteBaseEntity&amp;gt; {
    /**
     * 通过自定义注解执行查询的语句
     */
    public List&amp;lt;T&amp;gt; excuteQuery(T entity) {
        //[0]为getStackTrace方法，[1]当前的excuteQuery方法，[2]为调用excuteQuery方法的方法
        StackTraceElement parrentMethodInfo = Thread.currentThread().getStackTrace()[2];
        this.sqlHelper.convertSelfSql(parrentMethodInfo, entity);
        String jsonStr = SqliteHelper.query(entity.getCurrentSql(), entity.getCurrentParam(), this.getColumMap());
        if (jsonStr == null) return null;
        List&amp;lt;T&amp;gt; result = SqliteUtils.getInstance(jsonStr, entity.getClass());
        if (SqliteUtils.isNotEmpty(result)) {
            return result;
        } else {
            return null;
        }
    }
    /**
     * 通过自定义注解执行查询的语句
     */
    public List&amp;lt;T&amp;gt; excuteQuery(Object... params) {
        //[0]为getStackTrace方法，[1]当前的excuteQuery方法，[2]为调用excuteQuery方法的方法
        StackTraceElement parrentMethodInfo = Thread.currentThread().getStackTrace()[2];
        String sql = this.sqlHelper.convertSelfSql(parrentMethodInfo, params);
        List&amp;lt;Object&amp;gt; paramList = new Vector&amp;lt;Object&amp;gt;();
        if (null != params &amp;amp;&amp;amp; params.length &amp;gt; 0) {
            for (Object o : params) {
                paramList.add(o);
            }
        }
        String jsonStr = SqliteHelper.query(sql, paramList, this.getColumMap());
        if (jsonStr == null) return null;
        List&amp;lt;T&amp;gt; result = SqliteUtils.getInstance(jsonStr, this.entityClazz);
        if (SqliteUtils.isNotEmpty(result)) {
            return result;
        } else {
            return null;
        }
    }
    ...    
}

# 实体DAO中使用如下
public class TestTableDao extends SqliteBaseDao&amp;lt;TestTable&amp;gt; {
    @SqliteSql(sql = &amp;quot;select t.create_time publish_time,t.* from this.tableName t where name like '%'||?||'%'&amp;quot;, params = {&amp;quot;name&amp;quot;})
    public List&amp;lt;TestTable&amp;gt; getByName(TestTable entity) {
        //List&amp;lt;T&amp;gt; super.excuteQuery(T entity)，通过params上的参数顺序在entity中获取，并依次填充占位符
        return super.excuteQuery(entity);
    }
    @SqliteSql(sql = &amp;quot;select * from this.tableName where name like '%'||?||'%' or id=?&amp;quot;)
    public List&amp;lt;TestTable&amp;gt; getByNameOrId(String name, Integer id) {
        //List&amp;lt;T&amp;gt; super.excuteQuery(Object... params)，这里的参数顺序对应自定义的SQL的占位符顺序
        return super.excuteQuery(name, id);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    另外，自定义SQL注解对于像oracle这样的存储过程和函数占比较大的数据库，调用存储过程可是无往不利，不过就不知道占位符返回集合的存储过程或函数，方不方便数据的填充组装（TODO）。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;一个数据组装器&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    上面说到数据的组装，这也是比较关键的一个环节，只有这一步OK了，这个封装才算OK。总所周知，数据库表字段类型五花八门，想要很好的和java的类型对应上，确实要花费一点精力。这里为了节省时间和篇幅，个人取了个巧，将数据统一转化为JSON，然后统一通过json转对象。从代码上省去了复杂的类型对应，也摒弃了一个个取值，然后通过反射对应写值到对象属性里面的不安全操作及不确定异常，然而代价可能会对转化效率有影响。所以，关键就是需要一种不影响速度的json转化，fastjson基本满足条件。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;# SqliteHelper.java
/**
 * 根据结果集返回数据json
 */
public static String getDataJson(ResultSet rs, Map&amp;lt;String, String&amp;gt; columnMap) throws SQLException {
    String[] nameArr = null;
    List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; result = new ArrayList&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;();
    int rows = 1;
    while (rs.next()) {
        if (rows++ == 1) {
            nameArr = getNameArr(rs);// 获取列名
        }

        Map&amp;lt;String, Object&amp;gt; one = new LinkedHashMap&amp;lt;String, Object&amp;gt;();
        for (int i = 0; i &amp;lt; nameArr.length; i++) {
            String nameKey = null == columnMap ? nameArr[i] : columnMap.get(nameArr[i]);
            nameKey = null == nameKey ? nameArr[i] : nameKey;
            one.put(nameKey, rs.getObject(i + 1));
        }
        result.add(one);
    }
    String dataStr = SqliteUtils.getJsonList(result);
    System.out.println(&amp;quot;执行查询语句结果==&amp;gt; &amp;quot; + dataStr);
    return dataStr;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;# SqliteUtils.java
/**
 * 转换 List&amp;lt;Object&amp;gt; 为 Json字符串
 */
public static String getJsonList(List list) {
    if (list == null) return &amp;quot;[]&amp;quot;;
    StringBuffer jsonBuf = new StringBuffer(&amp;quot;[&amp;quot;);
    boolean flag = false;
    for (Object obj : list) {
        if (flag) {
            jsonBuf.append(&amp;quot;,&amp;quot;);
        }else{
            flag = true;
        }
        String jsonOne = getJsonObject(obj);
        jsonBuf.append(jsonOne);
    }
    jsonBuf.append(&amp;quot;]&amp;quot;);
    return jsonBuf.toString();
}
public static String getJsonObject(Object object) {
    try {
        String json = SqliteUtils.toString(JSONObject.fromObject(object));
        return json;
    } catch (Exception e) {
        e.printStackTrace();
        return &amp;quot;{}&amp;quot;;
    }
}
/**
 * json字符串转对象，转对集合
 * @param jsonString json字符串
 * @param clazz 对象class，如果要转化为List&amp;lt;ObjectA&amp;gt; 传入ObjectA.class
 * @return Object [返回类型说明]
 * @throws throws [违例类型] [违例说明]
 * @see [类、类#方法、类#成员]T
 */
public static &amp;lt;T&amp;gt; T getInstance(String jsonString, Class clazz) {
    if (SqliteUtils.isBlank(jsonString)) return null;
    if (&amp;quot;[]&amp;quot;.equals(SqliteUtils.trim(jsonString))) return null;
    Object json = new JSONTokener(jsonString).nextValue();//字符串 转json 类型对象
    if (json instanceof JSONObject) {  //这种   {&amp;quot;XXX&amp;quot;: &amp;quot;101&amp;quot;,{},[]} 对象
        return (T) SqliteJsonMapper.nonDefaultMapper().fromJson(json.toString(), clazz);
    } else {
        //如果集合不为null则是返回成功,则需要修改数据的时间
        //创建转换json的需要转换的集合类型   [{},{}]
        JavaType javaType = SqliteJsonMapper.nonDefaultMapper().contructCollectionType(List.class, clazz);
        return SqliteJsonMapper.nonDefaultMapper().fromJson(jsonString, javaType);//反序列化复杂List
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;验证和测试&lt;/h2&gt;
&lt;h3&gt;定义表结构实体&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * 测试表对应实体类
 * @author 欧阳洁
 * @create 2017-09-30 9:44
 **/
@SqliteTable(name = &amp;quot;t_test_table&amp;quot;)
public class TestTable extends SqliteBaseEntity {
    /**
     * 主键
     */
    @SqliteID
    private Integer id;
    /**
     * 名称
     */
    @SqliteColumn(type = &amp;quot;char(100)&amp;quot;, notNull = true)
    private String name;
    /**
     * 作者
     */
    @SqliteColumn(notNull = true)
    private String author;
    /**
     * 正文
     */
    @SqliteColumn(type = &amp;quot;text&amp;quot;)
    private String article;
    /**
     * 创建时间
     */
    @SqliteColumn(name = &amp;quot;create_time&amp;quot;,type = &amp;quot;char(20)&amp;quot;, notNull = true)
    private String createTime;
    /**
     * 查询类型 （非表字段）
     */
    @SqliteTransient
    private String searchType;
    /**
     * 发布时间 （非表字段）
     * 注：这里不使用SqliteColumn主键，默认的列名为publishtime
     */
    @SqliteTransient
    @SqliteColumn(name = &amp;quot;publish_time&amp;quot;)
    private String publishTime;

    //get、set此处省略
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;定义实体对应的Dao&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * Sqlite[t_test_table]的dao
 * @author 欧阳洁
 * @create 2017-09-29 17:17
 */
public class TestTableDao extends SqliteBaseDao&amp;lt;TestTable&amp;gt; {
    /**
     * 构造函数
     */
    public TestTableDao() {// 必须要对应实现父类的构造方法
        super(TestTable.class);// 表实体对应类
    }

    /**
     * 根据名称模糊查找数据
     * @param entity
     * @return
     */
    @SqliteSql(sql = &amp;quot;select t.create_time publish_time,t.* from this.tableName t where name like '%'||?||'%'&amp;quot;, params = {&amp;quot;name&amp;quot;})
    public List&amp;lt;TestTable&amp;gt; getByName(TestTable entity) {
        //List&amp;lt;T&amp;gt; super.excuteQuery(T entity)，通过params上的参数顺序在entity中获取，并依次填充占位符
        return super.excuteQuery(entity);
    }

    /**
     * 根据名称模糊查找数据并包含id查找
     * @param name
     * @param id
     * @return
     */
    @SqliteSql(sql = &amp;quot;select * from this.tableName where name like '%'||?||'%' or id=?&amp;quot;)
    public List&amp;lt;TestTable&amp;gt; getByNameOrId(String name, Integer id) {
        //List&amp;lt;T&amp;gt; super.excuteQuery(Object... params)，这里的参数顺序对应自定义的SQL的占位符顺序
        return super.excuteQuery(name, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;定义Dao对应的Service&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;/**
 * Sqlite[t_test_table]的service
 * @author 欧阳洁
 * @create 2017-09-30 15:16
 */
@Service
public class TestTableService extends SqliteBaseService&amp;lt;TestTable, TestTableDao&amp;gt; {
    public TestTableService() {// 必须要对应实现父类的构造方法
        super(TestTableDao.class);// 对应的Dao类
    }
    public List&amp;lt;TestTable&amp;gt; getByName(String name) {
        TestTable entity = new TestTable();
        entity.setName(name);
        return this.getBaseDao().getByName(entity);
    }
    public List&amp;lt;TestTable&amp;gt; getByNameOrId(String name, Integer id) {
        return this.getBaseDao().getByNameOrId(name, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;单元测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;//默认的方法测试，包括初始化检查表是否存在并构建、对象插入、对象查询（主键穿透查询）
————————————————————————————————————————&amp;lt;SqliteTest.java&amp;gt;—————————————————————————————————————
@Test
public void test2() {
    TestTableService sqliteService = new TestTableService();//没有使用spring注入，暂时自己构建
    TestTable entity = new TestTable();
    entity.setName(&amp;quot;test1&amp;quot;);
    entity.setAuthor(&amp;quot;petter&amp;quot;);
    entity.setArticle(&amp;quot;article1&amp;quot;);
    entity.setCreateTime(MyDate.getStringDate());
    sqliteService.insert(entity);
    entity.setName(&amp;quot;title2&amp;quot;);
    entity.setAuthor(&amp;quot;bob&amp;quot;);
    entity.setArticle(&amp;quot;article2&amp;quot;);
    entity.setCreateTime(MyDate.getStringDate());
    sqliteService.insert(entity);

    TestTable queryEntity = new TestTable();
    sqliteService.query(queryEntity);
    queryEntity.setAuthor(&amp;quot;petter&amp;quot;);
    sqliteService.query(queryEntity);
    queryEntity.setName(&amp;quot;test&amp;quot;);
    sqliteService.query(queryEntity);
    queryEntity.setId(1);
    sqliteService.query(queryEntity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test2()测试结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行非查询语句==&amp;gt; create table if not exists t_test_table(id integer  primary key autoincrement not null,name char(100)  not null,author char(20)  not null,article text ,&lt;font color='red'&gt;create_time&lt;/font&gt; char(20)  not null)
执行非查询语句影响行数==&amp;gt; 0
执行非查询语句==&amp;gt; INSERT INTO t_test_table(name,author,article,create_time)values(?,?,?,?)
执行非查询语句影响行数==&amp;gt; 1
执行非查询语句==&amp;gt; INSERT INTO t_test_table(name,author,article,create_time)values(?,?,?,?)
执行非查询语句影响行数==&amp;gt; 1
执行查询语句==&amp;gt; SELECT * FROM t_test_table WHERE 1=1
执行查询语句结果==&amp;gt; [{&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;test1&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;petter&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article1&amp;quot;,&amp;quot;&lt;font color='red'&gt;createTime&lt;/font&gt;&amp;quot;:&amp;quot;2018-02-20 22:54:32&amp;quot;},{&amp;quot;id&amp;quot;:2,&amp;quot;name&amp;quot;:&amp;quot;title2&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;bob&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article2&amp;quot;,&amp;quot;&lt;font color='red'&gt;createTime&lt;/font&gt;&amp;quot;:&amp;quot;2018-02-20 22:54:32&amp;quot;}]
执行查询语句==&amp;gt; SELECT * FROM t_test_table WHERE 1=1  and author=?
执行查询语句结果==&amp;gt; [{&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;test1&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;petter&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article1&amp;quot;,&amp;quot;&lt;font color='red'&gt;createTime&lt;/font&gt;&amp;quot;:&amp;quot;2018-02-20 22:54:32&amp;quot;}]
执行查询语句==&amp;gt; SELECT * FROM t_test_table WHERE 1=1  and name=? and author=?
执行查询语句结果==&amp;gt; []
执行查询语句==&amp;gt; SELECT * FROM t_test_table WHERE 1=1  and id=?
执行查询语句结果==&amp;gt; [{&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;test1&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;petter&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article1&amp;quot;,&amp;quot;&lt;font color='red'&gt;createTime&lt;/font&gt;&amp;quot;:&amp;quot;2018-02-20 22:54:32&amp;quot;}]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;//自定义的SQL查询测试，包含自定义SQL、结果集中额外列对应填充和查询对象属性值定位获取
——————————————————————————————————————&amp;lt;SqliteTest.java&amp;gt;——————————————————————————————————————
@Test
public void test3() {
    TestTableService sqliteService = new TestTableService();//没有使用spring注入，暂时自己构建
    List&amp;lt;TestTable&amp;gt; list = sqliteService.getByName(&amp;quot;test&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test3()测试结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行非查询语句==&amp;gt; create table if not exists t_test_table(id integer  primary key autoincrement not null,name char(100)  not null,author char(20)  not null,article text ,create_time char(20)  not null)
执行非查询语句影响行数==&amp;gt; 0
执行查询语句==&amp;gt; select t.create_time publish_time,t.* from t_test_table t where name like '%'||?||'%'
执行查询语句结果==&amp;gt; [{&amp;quot;&lt;font color='red'&gt;publishTime&lt;/font&gt;&amp;quot;:&amp;quot;2018-02-20 22:36:18&amp;quot;,&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;test1&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;petter&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article1&amp;quot;,&amp;quot;createTime&amp;quot;:&amp;quot;2018-02-20 22:36:18&amp;quot;}]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class="language-java"&gt;//自定义的SQL查询测试，这里直接撇开了实体类，可以任意的传参了，甚至调用存储过程或函数只需要一行注解就够了
———————————————————————————————————————&amp;lt;SqliteTest.java&amp;gt;—————————————————————————————————————
@Test
public void test4() {
    TestTableService sqliteService = new TestTableService();//没有使用spring注入，暂时自己构建
    List&amp;lt;TestTable&amp;gt; list = sqliteService.getByNameOrId(&amp;quot;title&amp;quot;, 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;执行非查询语句==&amp;gt; create table if not exists t_test_table(id integer  primary key autoincrement not null,name char(100)  not null,author char(20)  not null,article text ,create_time char(20)  not null)
执行非查询语句影响行数==&amp;gt; 0
执行查询语句==&amp;gt; select * from t_test_table where name like '%'||?||'%' or id=?
执行查询语句结果==&amp;gt; [{&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;test1&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;petter&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article1&amp;quot;,&amp;quot;createTime&amp;quot;:&amp;quot;2018-02-20 22:36:18&amp;quot;},{&amp;quot;id&amp;quot;:2,&amp;quot;name&amp;quot;:&amp;quot;title2&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;bob&amp;quot;,&amp;quot;article&amp;quot;:&amp;quot;article2&amp;quot;,&amp;quot;createTime&amp;quot;:&amp;quot;2018-02-20 22:36:19&amp;quot;}]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Git地址：&lt;a href="https://github.com/petterobam/my-sqlite"&gt;https://github.com/petterobam/my-sqlite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Git检出地址：https://github.com/petterobam/my-sqlite.git&lt;/li&gt;
&lt;li&gt;源码下载：&lt;a href="/upload/2018/02/rpdd0gs1vkhrvr3rlhh4khq8i6.rar"&gt;点击下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <pubDate>Wed, 21 Feb 2018 09:35:20 GMT</pubDate>
    </item>
    <item>
      <title>#2017-12-10# 关于代码提交、定版合并和打单包总结</title>
      <link>http://www.oyjie.cn/article/8</link>
      <content:encoded>&lt;h2&gt;前情提要&lt;/h2&gt;
&lt;p&gt;鉴于最近公司旅游及同学聚会，琐事蛮多，疏于记录，特提笔写写最近的东西。&lt;/p&gt;
&lt;p&gt;背景：前些日子，公司核心产品终测环境打包编译屡屡出问题，特此做一些通用总结。&lt;/p&gt;
&lt;h2&gt;代码提交&lt;/h2&gt;
&lt;h3&gt;每次提交的最小单位是安全的整体逻辑或弱关联文本&lt;/h3&gt;
&lt;p&gt;愿我们每个人都将代码提交演绎为一项神圣的仪式，了解提交的魅力。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;安全：不影响启动的逻辑、不影响原先业务的逻辑。
整体逻辑：保证不随意提交零散代码。整体提交能保证安全，拆开提交则有隐患。
弱关联文本：新增文件的时候，弱关联文本单独提交无隐患。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;整体逻辑定义&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1）一个业务功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2）一个服务功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3）单个bug的处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4）其他&lt;/p&gt;
&lt;p&gt;代码层面上逻辑闭合（基于SVN上已有的类的引用，做的一整套修改）以ASMS为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你&lt;font color="red"&gt;修改&lt;/font&gt;的是controller，则你需要检查对应的页面&lt;/li&gt;
&lt;li&gt;如果你&lt;font color="red"&gt;修改&lt;/font&gt;的是一个service，则你需要检查引用这个service的其他service和controller；&lt;/li&gt;
&lt;li&gt;如果你&lt;font color="red"&gt;修改&lt;/font&gt;的是一个&lt;font color="red"&gt;dao&lt;/font&gt;，则你需要检查对应的Mapper和service；&lt;/li&gt;
&lt;li&gt;如果你&lt;font color="red"&gt;修改&lt;/font&gt;的是一个&lt;font color="red"&gt;Mapper&lt;/font&gt;，则你需要检查对应的&lt;font color="red"&gt;数据库环境&lt;/font&gt;、dao和service；&lt;/li&gt;
&lt;li&gt;如果你&lt;font color="red"&gt;修改&lt;/font&gt;的是一个&lt;font color="red"&gt;entity&lt;/font&gt;（关联表的JavaBean），则你需要检查&lt;font color="red"&gt;所有&lt;/font&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，这些检查并不是真的要跑到每个地方去看，我们要善于利用intellij的编译工具和我们的经验，保证代码编译逻辑正确（启动）、业务逻辑正确（需求落实）、功能逻辑正确（需求落实+异常处理）&lt;/p&gt;
&lt;h4&gt;弱关联文本的定义&lt;/h4&gt;
&lt;p&gt;所谓的弱关联文本，就是不依赖或仅仅依赖于原来SVN的环境，不依赖于任何新的文件的文本，他们都可以直接提交。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;纯粹的弱关联文本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1)你&lt;font color="red"&gt;新增&lt;/font&gt;了一个JavaBean，并且引用的类和方法是原先SVN仓库里面已经有的，这样的JavaBean可以单独提交；&lt;/li&gt;
&lt;li&gt;2)你&lt;font color="red"&gt;新增&lt;/font&gt;了一个js、css或icon等static里面的静态文本，这些可以先单独提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有前提条件下的弱关联文本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1)&lt;font color="red"&gt;不影响启动的前提下&lt;/font&gt;，所有的static和view下吗的文件都是弱关联文本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;强关联文本的定义&lt;/h4&gt;
&lt;p&gt;有弱关联文本必有对应的强关联文本，这些东西的提交一定要有个概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1）所有于数据库交互的文本（&lt;font color="red"&gt;Mapper、Entity&lt;/font&gt;）或于数据库中间件交互的文本（&lt;font color="red"&gt;Dao&lt;/font&gt;）都是强关联文本，他们的新增都需要进行规范的检查，步骤从（数据库环境=&amp;gt;Entity[与数据库对应的JavaBean]=&amp;gt;Mapper=&amp;gt;Dao=&amp;gt;编译=&amp;gt;&lt;font color="red"&gt;启动自测&lt;/font&gt;）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2）所有使用到其他项目的类的类都是强关联文本，比如实现继承、spring注入、JavaBean引入实体等，需要进行规范的检查（[确认Mvn的版本是最近的，至少是三天以内的]=&amp;gt;编译=&amp;gt;&lt;font color="red"&gt;启动自测&lt;/font&gt;）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3）所有&lt;font color="red"&gt;系统配置文件&lt;/font&gt;都是强关联文本，包括&lt;font color="red"&gt;property&lt;/font&gt;、source下的&lt;font color="red"&gt;xml&lt;/font&gt;文件和maven工程的&lt;font color="red"&gt;pom&lt;/font&gt;文件，这些文档的提交需要找组长和对应的技术经理，系统框架级别的要找CTO的确认，禁止单独提交。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;每次提交都要遵照标准的提交步骤&lt;/h3&gt;
&lt;h4&gt;提交代码前的最低标准&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1)&lt;font color="red"&gt;所在环境编译无误&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;2)最高标准：所在环境启动无误，并且代码彻底解决了某个bug、完全实现了某个功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;小乌龟操作步骤&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1)更新你要提交的项目的代码（如有冲突，请先解决冲突，并返回1.2.1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2)Commit预览，预览时要确定两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a)要提交的文件的数量&lt;/p&gt;
&lt;p&gt;注：在排除了配置文件后的文件数量，配置文件找组长和技术经理提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;b)检查每个你要提交的java文件和Mapper文件，修改的地方是否是你的代码，避免提交他人的代码&lt;/p&gt;
&lt;p&gt;注：java文件要特别注意导入的包，很多情况下是导入了无用的包，导致了代码的问题，可以对自己的intellij idea做如下设置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/qjtsinc654j8mqb0u2rnorq1nd.png" alt="自动导包设置" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;勾选标注 1 选项，IntelliJ IDEA 将在我们书写代码的时候自动帮我们优化导入的包，比如自动去掉一些没有用到的包。 &lt;br/&gt;
勾选标注 2 选项，IntelliJ IDEA 将在我们书写代码的时候自动帮我们导入需要用到的包。但是对于那些同名的包，还是需要手动 Alt + Enter 进行导入的&lt;br/&gt;
&lt;font color="red"&gt;一般勾选标注 1 即可&lt;/font&gt;，标注 2 不勾选，有利于我们在编程的时候了解一些工具类的路径，这是一个即时学习的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3)写好备注&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a)如果是bug，请附上bug的标题及ID，详细可以追加产生原因和处理方案，总结的过程，提升贼快；&lt;/li&gt;
&lt;li&gt;b)如果是需求，请附上需求说明，及该批代码完成了需求的哪一块；&lt;/li&gt;
&lt;li&gt;c)如果是其他功能，请附上功能描述，及完成了该功能的哪一块；&lt;/li&gt;
&lt;li&gt;d)如果是其他，请附上明确备注&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4)提交，并跟进相关环境的更新情况，及时查看代码影响的模块，自测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;提交情况告知组长&lt;/h4&gt;
&lt;p&gt;组长有义务监督组员代码的提交，特别是定版的代码提交，但是提交过程何其多，组长无法一一顾及，所以需要组员主动汇报组长自身提交的动态，不然出了问题组长会很不爽哦。&lt;/p&gt;
&lt;p&gt;&lt;font color="red"&gt;提交完开发环境&lt;/font&gt;，需要告知组长，可以简单的发个消息，告知你提交的版本、描述和时间。&lt;/p&gt;
&lt;p&gt;当然，个人建议可以用通讯工具建立一个组内代码提交动态群，组长可以浏览每天的提交动态。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/1hoihoum3ugcrqqhos1akaq7hu.png" alt="组内代码提交群" /&gt;&lt;/p&gt;
&lt;h2&gt;定版合并&lt;/h2&gt;
&lt;p&gt;SVN开发版本到定版的代码迁移过程，称为定版合并过程。&lt;/p&gt;
&lt;h3&gt;定版合并先决条件&lt;/h3&gt;
&lt;h4&gt;保证合并的代码来源无误&lt;/h4&gt;
&lt;p&gt;开发版的代码需要满足解决了某个bug，完成了某个需求，实现了某个功能，并测试通过。&lt;/p&gt;
&lt;h4&gt;待合并的版本清单&lt;/h4&gt;
&lt;p&gt;清楚要合并的代码在开发版上的提交版本清单，需要合并哪些提交记录，才能组成一个逻辑整体。&lt;/p&gt;
&lt;h4&gt;明确清楚合并顺序&lt;/h4&gt;
&lt;p&gt;当出现多个模块合成一个整体逻辑的时候，明确清楚合并顺序。例如修改了OpenApi，如果有其他的合作项目，则其他项目的合并在前。&lt;/p&gt;
&lt;h3&gt;定版合并步骤&lt;/h3&gt;
&lt;p&gt;定版合并前一定要保证开发版代码正确，否则合并定版就如同一场儿戏。&lt;/p&gt;
&lt;h4&gt;Merge的原则和原理&lt;/h4&gt;
&lt;p&gt;Merge是一个代码选择性拷贝的过程，了解其原理有助于我们更流畅的Merge，减少发生冲突的次数及减轻对冲突的恐惧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1)先更新你需要提交的项目目录。&lt;/p&gt;
&lt;p&gt;只要你的本地代码在版本中，更新必定不会产生冲突。定版代码我们都不会手动在上面编辑，所以更新的时候不会与你的定版代码冲突，如有冲突，说明你对本地的定版代码做了编辑修改，这个时候只需要还原整个项目的代码，在进行更新即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2)选择对应的远程版本，Merge预览&lt;/p&gt;
&lt;p&gt;少量的代码合并很容易Merge，但也不能轻视，往往就是这种情况让我们掉以轻心。&lt;/p&gt;
&lt;p&gt;大量代码的合并可能让我们疲于应付，但是Merge只是一个代码远程Copy的过程，这里可以简单的分享一些技巧。&lt;/p&gt;
&lt;p&gt;背景1：例如，你最近半个月都在做一个需求项目，并且你们组的其他人也全部参与其中，在这期间你的组员可能还时不时改改其他业务bug，但是跟这个新项目有关的东西在没做完前都只能提交开发的SVN。这种情况下，我就会定下规矩，关于新需求项目的代码提交备注统一添加前缀——XXXXX项目：[你的SVN备注]。如此一来，半个月之后，项目开发完成后，需要在终测上测试了，这个时候我利用Merge预览就可以轻松找到我要合并的代码，而这些代码集合就是这个项目的整体逻辑，高效、完美。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.通过&lt;font color="red"&gt;Next 100&lt;/font&gt;按钮调整你的项目开始时间From&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;b.通过小乌龟的通配搜索功能，记住使用正则功能一定要勾选 &lt;font color="red"&gt;use regular expression&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;c.有些备注模糊不清的地方，组长需要找到对应的组员确认，&lt;font color="red"&gt;并纠正告诫&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/3i7nfqp7vkjd7qs1461v4g6ov0.png" alt="svn的merge示例" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，开始Merge，庆幸的是该项目的Merge没有出现任何冲突，虽然归功于良好的注释和整体逻辑的提交原则，但是这并不意味着不会出现冲突的Merge情况了。&lt;/p&gt;
&lt;p&gt;往往一个项目时长越长，业务关联越多，可能出现的问题也会越多，牵扯到的业务越多，交叉修改文件的频率也会越频繁，这样通过搜索出来的的文件很大概率跨了很多未合并的版本。&lt;/p&gt;
&lt;p&gt;例如，我在版本里面随机选择一些版本进行合并&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/vjvk33sq74iajologp27rhem3h.png" alt="随机代码合并" /&gt;&lt;/p&gt;
&lt;p&gt;这种文件树的冲突，一般指文件夹，就算是文件也可以直接不管，标记为已解决即可&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/slmsm4v218j9mrjfu7jfmvbrrf.png" alt="文件夹冲突" /&gt;&lt;/p&gt;
&lt;p&gt;像这种文件类的冲突，如果你不擅长或不确定如何Edit conflict，可以先选择合并接收开发版本的SVN最新版，快速完成Merge的过程，并且确保你的代码能过来是最重要的。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/23oi0ni1mqggbpfhdmond8ftac.png" alt="文件冲突" /&gt;&lt;/p&gt;
&lt;p&gt;这样，你的代码就“毫无Conflict”的情况下Merge到了本地的定版，这样就结束了吗？&lt;/p&gt;
&lt;p&gt;No，上面都是无关紧要的必要步骤，下面的才是重中之重。&lt;/p&gt;
&lt;h4&gt;有意识的检查&lt;/h4&gt;
&lt;p&gt;检查是一项很枯燥的工作，很容易让人失去耐性，但是如果是有意识的检查，有明确的目标，那么这项工作就变得流畅而富于意义，至少对于当时的你是这样的。&lt;/p&gt;
&lt;p&gt;首先打开你Merge的项目的提交预览界面，不要写提交备注&lt;/p&gt;
&lt;p&gt;预览要确定的一些东西，即目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a)要提交的文件的数量&lt;/p&gt;
&lt;p&gt;注：在排除了配置文件后的文件数量，配置文件找组长和技术经理提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;b)检查每个你要提交的java文件和Mapper文件&lt;/p&gt;
&lt;p&gt;注：确定修改的地方是你的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;c)&lt;font color="red"&gt;重点检查Merge过程中发生过冲突的文件&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;注：这样的文件必定是少量，如果有很多，你就要慎重一点了，找找原因你会发现，可能有正在130测试中的需求没有合并到定版，也可能会有很久远的代码没有合并到定版了，然后幸运的被你发现了，&lt;font color="red"&gt;解决他&lt;/font&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提问：如果Merge过程中，没有出现一次&lt;font color="red"&gt;Conflict&lt;/font&gt;的提示，是不是意味着可以绝对不会有问题？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;答：不是。这只能说明你Merge的代码一定是你提交的那些代码，如果是一个整体逻辑，那确实没有问题，可是问题是可能不是一个整体逻辑，比如出现1.2.2中你提交到开发版有&lt;font color="red"&gt;import&lt;/font&gt;无用的包，恰好你没有设置自动清除无用的包，而这个依赖的类在定版正好没有，那你的这次提交就是一个&lt;font color="red"&gt;伪整体逻辑&lt;/font&gt;，就会导致定版启动异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何判断你的每一次提交是否是整体逻辑呢？下面的步骤才是无罪证书获取流程。&lt;/p&gt;
&lt;h4&gt;编译都没问题了，那才是没问题&lt;/h4&gt;
&lt;p&gt;我们用intellij idea打开我们定版的工程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1)确保你定版的idea工程的Maven是三天以内的版本（看overlay里面的子项目时间）。&lt;/li&gt;
&lt;li&gt;2)确保idea工程的每个Module是最新的，不是就更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开idea工程的Maven Projects，展开你要提交的子项目的lifecycle，clear、compile，
&lt;font color="blue"&gt;Process finished with exit code 0&lt;/font&gt; 代表你可以喝口茶了。&lt;/p&gt;
&lt;p&gt;最后，提交代码，再次简单检查一下，写好备注，提交代码，并实时关注终测环境的更新状态，确保你提交的代码不但安全，并且有效（满足了需求？解决了问题？实现了功能？）。&lt;/p&gt;
&lt;h2&gt;定版打单包&lt;/h2&gt;
&lt;p&gt;&lt;font color="red"&gt;如果是用于终测或客户环境，请在本地定版打单包&lt;/font&gt;。&lt;/p&gt;
&lt;h3&gt;定版打包的先决条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1)保证定版idea项目Maven是三天以内&lt;/li&gt;
&lt;li&gt;2)保证你要打包的子项目Maven编译无误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;定版打包的技巧&lt;/h3&gt;
&lt;h4&gt;定版打单包的痛点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;font size="20px"&gt;慢！&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;借助我们原来的打包工具&lt;/p&gt;
&lt;p&gt;和与tomcat一致的子目录&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/6e36b3aj6ii6cr09jcph8npa99.png" alt="tomcat发布包" /&gt;&lt;/p&gt;
&lt;p&gt;请问你要什么样的包，我都可以给你。&lt;/p&gt;
&lt;p&gt;定版打包让人比较难受的是，编译启动太耗时间，然而这往往是喜欢从主项目的target目录下打包的人的烦恼，当然这种情况打的包自然是没问题，但是要全部编译并发布到主项目target太耗时，特别是我们的核心产品的项目。&lt;/p&gt;
&lt;p&gt;但是回头想想，为啥当初要将一个项目分离成这么多个项目，不就是为了降低不同组之间的相互影响，如果每个组自身的代码没有problem，那么整个项目就理应No problem。同理，打包原理也是类似，可以分离打包，基于tomcat的特性，我们如果能够创造那样的目录结构和所需的文件，借助打包工具，往往会事半功倍呢。&lt;/p&gt;
&lt;h4&gt;定版打单包的技巧&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1)在桌面创建一个文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/pbumj6iq4sjnioqhh06mr579m2.png" alt="打包区" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2)将你要打包的定版子项目webapp文件夹下的文件夹拷入其中&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/774mlo5nbkhs3ra142t0t02alk.png" alt="子项目目录" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/54o0qq6iregvap1fu7c7a3cd65.png" alt="打包子项目" /&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你打包的项目里面没有static类的文件可以不拷贝static文件夹，如果没有view类文件，课可以不拷贝WEB-INF文件，直接新建一个WEB-INF文件夹即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3)在idea定版项目上Maven clear、compile你的子项目&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/5g5r10utkihfaok3silof1fg0m.png" alt="子项目编译" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4)确保编译无误后，将你要提交的项目下的target文件下的classes文件夹拷入WEB-INF目录中&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/ptngqv77vehocpuga81lvpc0oi.png" alt="子项目编译结果" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5)然后就创造了单个子项目的打包环境&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/pphm6r3he2hgjo9gpv8oke257k.png" alt="项目打包区" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6)根据提交记录打包&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/12/pfphd8dp0ehsep0befqrjnel1p.png" alt="SVN提交日志" /&gt;&lt;/p&gt;
&lt;p&gt;注：如果文件成批的在某个文件夹内，可以批量的拖进打包工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded>
      <pubDate>Sun, 10 Dec 2017 12:35:07 GMT</pubDate>
    </item>
    <item>
      <title>#2017-11-06# Word、PDF解析项目（二）</title>
      <link>http://www.oyjie.cn/article/7</link>
      <content:encoded>&lt;h2&gt;前情提要&lt;/h2&gt;
&lt;p&gt;前面说了一个偏技术方向的文档解析类的项目，当普通人看到那些五花八门的文档情不自禁就会把项目结果，想象成构造复杂、难以理解、代码高深的集合体。其实，说实话，在没有去了解具体的文档和内容的时候，我心中也是没有底的一个情况，毕竟这种没有限制的文档文本，穷举法是不切实际的做法，但是当你着手去设计的时候，越来越发现，其实，并不复杂。当然，不要急着去编码，第一步的思考总是错的（模板），而第二步思考往往就是正确的方向，如下是我对这个项目的一个比较完整的设计思路，大部分是在解析方面用到的工具。&lt;/p&gt;
&lt;h2&gt;解决文档结构的差异&lt;/h2&gt;
&lt;p&gt;Word、PDF在文件结构上的结构有所不同，就连Word家的Doc和Docx也大不相同。然而想要解决这种差异，作为总是接触Web项目的工程师，情不自禁的就想：把他们全部转成HTML格式。&lt;/p&gt;
&lt;p&gt;我们都知道，其实映入我们眼帘的Word、PDF文档在视觉上是二维的一个结构，如果有不是太合法规矩的Word文档会有悬浮的文本框和图片，这貌似又变成了&amp;quot;三维“的文档了。但是HTML文档我们都清楚，如果我们能有效的解决了代码里面的浮动，文本的结构可以看成是一维的结构，文档拉成字符串的顺序和我们阅读的顺序一模一样。&lt;/p&gt;
&lt;p&gt;1)、DOCX使用org.apache.poi.xwpf转成HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a)、加载文件DOCX文件流，创建解析文档
document = XWPFDocument(文件流:InputStream);
b)、针对图片，创建额外的解析器
XHTMLOptions options = 图片解析器(图片输出路径);
c)、定义输出流（out），转化输出
XHTMLConverter.getInstance().convert(document, out, options);
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
2)、DOC使用org.apache.poi.hwpf转成HTML
&lt;pre&gt;&lt;code&gt;a)、加载文件DOC文件流，创建解析文档
document = HWPFDocument(文件流:InputStream);
b)、针对图片，定义图片管理器
WordToHtmlConverter.setPicturesManager(PicturesManager)
c)、解析DOC，转化输出
htmlDocument = WordToHtmlConverter.processDocument(wordDocument);
Transformer(htmlDocument,out);
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
3)、PDF使用插件pdf2htmlEX转成HTML
&lt;pre&gt;&lt;code&gt;Windows 通过Runtime.getRuntime().exec 执行插件，产生的输出流写入转化文档
Linux 需要安装pdf2htmlEX脚本，同理通过Runtime.getRuntime().exec 执行命令解析
转化的图片地址为base64位字符串，需要将其转存图片
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上提到的具体代码，请根据标题自行百度学习 ( • ̀ω•́ )✧&lt;/p&gt;
&lt;h2&gt;切块：反正都一样，但是小的更好&lt;/h2&gt;
&lt;p&gt;呀，通过上面的步骤，终于不用打Word、PDF文档了，他们已经全部变成了HTML文本了(￣▽￣)。&lt;/p&gt;
&lt;p&gt;这个时候有人跳出来了，说：下面就简单了，这就变成了一个爬虫抓取问题了，这个我会。&lt;/p&gt;
&lt;p&gt;但是，真正做了上面转成HTML文档的人才能看出来，真正的难题才刚刚开始。总所周知，爬虫是根据某些网站的HTML文档的某些标识、属性、结构进行数据提取，然而解析出来的HTML没有ID、class以及特殊的属性，结构上也是没有规律的各种嵌套，甚至“相同&amp;quot;的文档，解析出来的HTML在HTML结构上会略有不同，虽然浏览器打开的HTML界面结果是一样的。而且，前面讲到不同旅行社、计调产出的风格不同，转成的HTML也是截然，相当于爬虫解析不同的网站，这样要定制不同的爬虫规则，和做模板大同小异，又回到穷举问题。 &lt;em&gt;(:з」∠)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当然，解决问题才是关键，不能既提出一个无解的问题，又不思考和实践解决方案。文档有两个至关重要的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人做的&lt;/li&gt;
&lt;li&gt;旅游相关，准确点是和线路行程相关&lt;/li&gt;
&lt;/ol&gt;
&lt;br/&gt;
人是一种逻辑思维动物，人做的文档有上下文关系，这和机器生成的随机码不一样，这是一个重要特点，上下文关系。旅游线路行程相关，这就有了行业特点，缩小了解析范围，行业特点就我们系统而言是可以进行穷举的，在模块上。综上，就是：可穷举的有上下文关系的旅游行业的线路行程的HTML文档。
&lt;p&gt;于是，可穷举就有一个最小单位，我们可以将一个大的HTML文档，通过穷举的项和上下文关系特性，将其切成一个个HTML文本小块，这就是文本切块的工具原理，穷举就是文档中的小标题关键字。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/11/o1f2odqll6ijtqhtuf14uqibvh.png" alt="文本切块设计" /&gt;&lt;/p&gt;
&lt;p&gt;当然，这上面的锚点有效性的定义上还要解决一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标题被标签分隔。在文档转HTML的时候可能在文本逻辑上被不换行标签（span、label）等分隔，或者还有某些文档标签由于制作者的粗心会有空格特殊字符等夹杂其中，亦或者文档的标题结构是竖着排的等情况。而这些情况都需要在切块之前处理好。所幸，这些都是在程序允许范围内可以有效杜绝的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正文中可能含有标题关键字。这种情况下，在上面处理了随机出现的不换行标签后，整行的文字就在一个标签里面了，可以&lt;font color="red"&gt;根据HTML标签成对的闭合性，计算出关键文字占所在的最近父标签内总文字的百分比&lt;/font&gt;，百分比高者一般就是真正的标题，也就是正文开始的地方。而这个方法也是切块算法的一个重要成分，叫&lt;font color="red"&gt;容占比高优法&lt;/font&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找到正确的锚点之后，然后根据锚点排序，就可以有序的将文本切成一块块的小个体，如果过程中做好分类，还可以将相似的块合并。切块之后，大的文本变成了小的文本，小文本特征更加单一明确，数据提取更简单。不过还是有很多问题，比如上面的切块是属于一种非常暴力的方式，导致很多标签残缺，特别是像表格这种组合标签，需要先进行修复才能后续的正常解析和用于显示。&lt;/p&gt;
&lt;h2&gt;Jsoup：学会HTML的正确打开姿势&lt;/h2&gt;
&lt;p&gt;既然前面一直是基于HTML，那么HTML的特性DOM需要好好利用起来。java的HTML解析器目前比较出名的像Jsoup、Xpath等，不过由于Jsoup语法更接近JQuery，所以我选择了Jsoup。利用到Jsoup后，文本就可以一口气变成一个DOM元素集，可以进行很方便的元素扣取，特别是对表格和图片的处理，简直如有神助。当然，要把它变成一个工具，需要先让他很流畅的支持批量提取数据的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/11/tfe78als5ags6opjamkvvsupsi.png" alt="元素扣取设计" /&gt;&lt;/p&gt;
&lt;p&gt;从该工具中衍生了一套表格数据处理的方法，包括错位表格、跨行、跨列表格数据的定位和提取。&lt;/p&gt;
&lt;h2&gt;正则：更快更精确还可以模仿招式&lt;/h2&gt;
&lt;p&gt;我们都知道正则源于文法重点3型文法，对应于有限状态自动机，好吧，我们或许不知道（&lt;a href="https://www.2cto.com/kf/201411/356617.html" title="点击了解"&gt;点击了解&lt;/a&gt;）。所以，我们对正则算法的匹配效率不需要过多讨论，反正要达到类似的效果正则是比较高效的。然而，我们知道java的正则表达式真正耗时的不是索引取取数据的时间，而是用正则表达式compile文本的时间，有效的减少正则的compile，就需要简单的对原来的正则表达式进行封装，让离散的数据一次性的变成有效的数据集。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/11/tlhc3ptl4egqdp9sgk5l72j9jd.png" alt="正则匹配设计" /&gt;&lt;/p&gt;
&lt;p&gt;正则除了可以做复杂的预判和替换外，批量匹配的正则单元具有开始结束索引和组的这两个重要的特征。索引可以模仿切块功能的锚点，实现更为复杂的切块，比如行程信息中精确到每天的行程信息解析，就是利用这种变形版的正则切块法，直接有效区分解析非表格风格的行程，当然也可以针对表格风格的行程（不过一般情况下，表格风格的行程用Jsoup解析效果更佳）。组就相当于提取到的有效数据，是一种更加自由的元素扣取，不用像Jsoup这样，要规范的HTML文本才能有效扣取。另外，切块中的容占比计算也用到了正则工具。&lt;/p&gt;
&lt;h2&gt;用点分词和聚类&lt;/h2&gt;
&lt;p&gt;当大部分数据都出来了之后，我们就要精雕细，处理那些顽固数据。例如，线路行程里面的城市数据，这种无法方便穷举的城市数据匹配，对词这个最小单元要有很高效的解析，而且还要是城市的单词。幸好我们公司有Elasticsearch，旅游方面实现了针对我们库的一个城市提取服务。当然，这个项目的内部我也添加了Lucene分词，用于备用情况下生成某些有概括性的语义小标题，结合2012年的IKAnalyzer可以达到每秒600万字的解析量，解析时间可以忽略不计。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/11/puj9e12nocg4vpp7jcpaqm1s0t.png" alt="分词和聚类" /&gt;&lt;/p&gt;
&lt;p&gt;聚类，貌似牵扯到了一点点数据分析，其实用到它只是为了解决一个比较关键的问题：那就是确保行程数据按天为单位可以达到连续有效。对于行程数据，这种极具统一风格的信息，我统计出了近10种风格，但是这是人做的文档，一般情况下风格都是相同的。加之容占比排除等等的作用，可以很有效的提取到每天的行程。然而，如果正文中出现了其他行程如何处理，恰恰这种时候容占比也不能排除（非表格格式的行程信息多见）。就好比我们用正则切块匹配到了多种风格的锚点，这样就会打乱锚点的顺序，第二天和第三天中间多了个“第5天”，第三天和第四天之间多了个“第1天”，聪明的我们已然了解到需要排除“第5天”和“第7天”的这两个数据，他们的风格不对。而聚类就是统计这些风格出现的次数，次数高者得胜，其他淘汰。&lt;/p&gt;
&lt;h2&gt;细节解析数据流向简图&lt;/h2&gt;
&lt;p&gt;&lt;img src="/upload/2017/11/09cva0dp1ujuopcuohcivjti8a.png" alt="细节设计" /&gt;&lt;/p&gt;
&lt;h2&gt;全自动匹配&lt;/h2&gt;
&lt;p&gt;其实，一开始我一直想避免模板，但是有人可能已经发现，在上面用到了模板，那就是切块。只是这个模板是文档标题，一般是旅游的各个模块，属于行业术语。虽然，有些术语不同地方叫法略有差异，但是配置门槛较低，也可以针对性的穷举。那么如果假设我们有一个穷举库，我们是不是可以达到自动匹配呢？当然可以。但是当时我这个项目没有分配数据库，而且我觉得操作数据库也极大的影响了性能，只做了一个简要的自动匹配。“模板”是用SQLIT录入和存储的，在项目启动的时候加载到缓存可以，避免频繁的数据库操作。由于没有评分系统，不能对各个模板进行优先级排序和特征记录，所以自动匹配只是粗暴的通过匹配到的数据数量高低来做判断优劣，不能自动运转优化。&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/11/o770vech6ijjaojp3pl93i9930.png" alt="自动匹配解析" /&gt;&lt;/p&gt;
&lt;h2&gt;后续&lt;/h2&gt;
&lt;p&gt;关于这个项目的思想主要就是这么一些，后续会尝试分享一些编码的经验...&lt;/p&gt;</content:encoded>
      <pubDate>Mon, 06 Nov 2017 15:00:17 GMT</pubDate>
    </item>
    <item>
      <title>#2017-10-25# Word、PDF解析项目（一）</title>
      <link>http://www.oyjie.cn/article/6</link>
      <content:encoded>&lt;h2&gt;前情提要&lt;/h2&gt;
&lt;p&gt;前一段时间做了文档解析相关的微服务，当然是和业务背景相关的业务数据提取，并不是对任何文档都能提取出正确的数据，而是针对旅行社的线路行程文档做的针对性解析服务。&lt;/p&gt;
&lt;h2&gt;应用场景&lt;/h2&gt;
&lt;p&gt;旅游行业供应商旅行社使用的B端软件有一个痛点，就是线路行程数据录入复杂耗时。由于不同旅行社线路行程文档风格几乎都不相同，即便是同一旅行社不同计调做出的文档风格也有所差异，即便是同一计调针对不同的类别的线路在不同的时期做出的文档也会有所不同。甚至有些旅行社是作为代理商，拿他们的产品做分销，又有更多无法控制的情况。如果按照常规做法，每一种风格的文档做一种文档模板（Word+PDF），每一种模板对应一种解析方式，这将是无法估计的工作量，特别在软件线路行程文档或业务数据若有变动的话，会有很大的迭代成本，相应的的维护代价和门槛也会变高。但是如果不做文档模板，如何保证准确性和稳定性呢，如何保证工作量可估量，如何保证后续的稳定迭代和有效的维护。&lt;/p&gt;
&lt;h2&gt;项目设计&lt;/h2&gt;
&lt;p&gt;项目启动初，需要给一个初步的项目设计，下面是项目内部的结构设计：&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/10/sovpst1pemgfpo1dek227p0hm3.png" alt="项目框架设计" /&gt;&lt;/p&gt;
&lt;p&gt;简化起来大概就是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/10/oeuh04e7eei4voal7r261gpsjh.png" alt="项目框架设计" /&gt;&lt;/p&gt;
&lt;h2&gt;时间计划&lt;/h2&gt;
&lt;p&gt;项目启动后，需要给一个简要的功能计划和时间的预估：&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/10/1r5a0svnjainsoo89q7t5p9apt.png" alt="项目框架设计" /&gt;&lt;/p&gt;
&lt;h2&gt;框架架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;精简 SpringMVC+Spring+Mybatis 框架配置；&lt;/li&gt;
&lt;li&gt;支持druid控制台，监控请求、数据库和服务方法的性能；&lt;/li&gt;
&lt;li&gt;支持页面和Controller交互，JSON和对象的自动互相转换；&lt;/li&gt;
&lt;li&gt;提供公共服务，也支持按业务线扩展开发；&lt;/li&gt;
&lt;li&gt;支持JUNIT4测试和日志监控功能；&lt;/li&gt;
&lt;li&gt;支持事务监控，自定义监控；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;功能清单&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;文件读取解析 框架搭建&lt;/li&gt;
&lt;li&gt;文件工厂实现&lt;/li&gt;
&lt;li&gt;文件读取适配器实现 搭建&lt;/li&gt;
&lt;li&gt;DOC读取适配器实现文档转HTML/XHTML，及其相关预处理&lt;/li&gt;
&lt;li&gt;DOCX读取适配器实现文档转HTML/XHTML，及其相关预处理&lt;/li&gt;
&lt;li&gt;PDF读取适配器实现文档转HTML/XHTML，及其相关预处理&lt;/li&gt;
&lt;li&gt;HTML读取、解析器实现&lt;/li&gt;
&lt;li&gt;文件对外读取服务实现&lt;/li&gt;
&lt;li&gt;解析区模块构建分析&lt;/li&gt;
&lt;li&gt;文本切块定义和设计&lt;/li&gt;
&lt;li&gt;文本切块实现&lt;/li&gt;
&lt;li&gt;元素扣取定义实现&lt;/li&gt;
&lt;li&gt;正则匹配定义实现&lt;/li&gt;
&lt;li&gt;业务方解析转化模式搭建和设计&lt;/li&gt;
&lt;li&gt;旅游业务线路、行程和团队规则数据结构设计和定义&lt;/li&gt;
&lt;li&gt;线路行程数据加工以及旅游对外服务实现，接收文件或文件地址解析&lt;/li&gt;
&lt;li&gt;高级配置界面设计&lt;/li&gt;
&lt;li&gt;高级配置界面实现&lt;/li&gt;
&lt;li&gt;ASMS对接服务导入WORD文档自动生成线路&lt;/li&gt;
&lt;li&gt;ASMS对接服务导入WORD文档自自动生成行程&lt;/li&gt;
&lt;li&gt;串联所有模块进行测试，实现线路、行程自动导入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;后续&lt;/h2&gt;
&lt;p&gt;细节实现和项目过程中遇到的问题后续更新...&lt;/p&gt;</content:encoded>
      <pubDate>Thu, 26 Oct 2017 02:13:49 GMT</pubDate>
    </item>
    <item>
      <title>#2017-09-22# 初体验·项目管控心得</title>
      <link>http://www.oyjie.cn/article/5</link>
      <content:encoded>&lt;p&gt;依据个人这两个月的项目管控体验，总结了在我们公司项目管控一些相关的要注意的地方。&lt;/p&gt;
&lt;h2&gt;项目设计和安排&lt;/h2&gt;
&lt;p&gt;项目开始前需要有一份初步的计划。&lt;/p&gt;
&lt;p&gt;项目设计中要确定的元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要做啥 —— 找产品经理确认&lt;/li&gt;
&lt;li&gt;做成啥样 —— 找产品经理确认&lt;/li&gt;
&lt;li&gt;如何去做 —— 根据以上去设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;项目计划中的安排主要是对工时的预估和排布，要明确的元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计划总工时 —— 决定上线时间范围&lt;/li&gt;
&lt;li&gt;计划详细时间安排 —— 决定参与人员数量和要求的战力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;项目每日进度管控&lt;/h2&gt;
&lt;p&gt;在项目的开发阶段，难免会遇到影响进度的问题，需要实时管控。&lt;/p&gt;
&lt;p&gt;日常管控过程中涉及：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每日进度汇总
&lt;ol&gt;
&lt;li&gt;参与项目每个人进度&lt;/li&gt;
&lt;li&gt;汇总项目每个人进度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每日异常汇总
&lt;ol&gt;
&lt;li&gt;统计项目每个人异常&lt;/li&gt;
&lt;li&gt;汇总项目每个人异常&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每日变更汇总
&lt;ol&gt;
&lt;li&gt;根据项目进度、异常调整项目安排&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每日文件汇总
&lt;ol&gt;
&lt;li&gt;统计项目每个人文件&lt;/li&gt;
&lt;li&gt;汇总项目每个人文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每日代码检查
&lt;ol&gt;
&lt;li&gt;每日个人代码检查&lt;/li&gt;
&lt;li&gt;挑选出特例讲解&lt;font color="red"&gt;解决方案&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;管控日志要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如实录入 —— 利于统计评估组员综合能力&lt;/li&gt;
&lt;li&gt;要做汇总 —— 经常看整体项目进度&lt;/li&gt;
&lt;li&gt;异常变更要明确 —— 到人到时&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;测试管理&lt;/h2&gt;
&lt;p&gt;在项目开发完成后，需要进行简单的一轮测试，而测试过程中的侧重点则需要根据测试用例。&lt;/p&gt;
&lt;p&gt;一轮测试重点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无低级错误 —— 直接报错类型&lt;/li&gt;
&lt;li&gt;无业务逻辑错误 —— 影响原有流程&lt;/li&gt;
&lt;li&gt;满足最低要求 —— 视不同项目情况而定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试点 —— 产品方列出&lt;/li&gt;
&lt;li&gt;测试方法 —— 产品方给出描述&lt;/li&gt;
&lt;li&gt;测试统计 —— 产助统计结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试跟进：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带领项目参与人解决测试产生bug，争取一轮测试问题在一天的时差以内解决&lt;/li&gt;
&lt;li&gt;项目经理需要汇总安排产生的bug，bug记录每日需要产助统计给项目经理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;上线管理&lt;/h2&gt;
&lt;p&gt;参与人的代码提交&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列出项目相关的环境（CPS、ASMS、CPSLINK、ES、ESLINK、CDS、图片服务器、文件服务器等）&lt;/li&gt;
&lt;li&gt;根据环境列出&lt;font color="red"&gt;前台、后台&lt;/font&gt;补丁，给出表格&lt;/li&gt;
&lt;li&gt;参与人给出自己的定版提交记录或补丁文件，填到对应表格&lt;/li&gt;
&lt;li&gt;项目经理汇总&lt;/li&gt;
&lt;li&gt;交由产助跟进更新事宜（一般需要协助产助）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上线后的非代码统计跟进&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要添加的环境配置清单&lt;/li&gt;
&lt;li&gt;要开启的接口权限清单&lt;/li&gt;
&lt;li&gt;服务器的内外网确认&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上问题排查最终要以终测环境OK为准，自觉自测。&lt;/p&gt;
&lt;h2&gt;项目验收&lt;/h2&gt;
&lt;p&gt;正常上线之后，需要对项目进行验收，项目经理需要给出相应的文档&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;立项表&lt;/li&gt;
&lt;li&gt;时间安排表&lt;/li&gt;
&lt;li&gt;测试清单&lt;/li&gt;
&lt;li&gt;项目奖分配清单&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;产品经理作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在项目需求不明确时，需要找产品经理确认&lt;/li&gt;
&lt;li&gt;在项目逻辑不明朗时，需要找产品经理核实&lt;/li&gt;
&lt;li&gt;在项目时间不可控时，需要找产品经理沟通&lt;/li&gt;
&lt;li&gt;产品经理需要定期查看项目情况，避免结果与需求不符&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;产品助理作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;协助跟进项目&lt;/li&gt;
&lt;li&gt;协助确定需求&lt;/li&gt;
&lt;li&gt;协助推进项目&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;技术经理作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在技术实现有困难时，需要找技术经理商榷&lt;/li&gt;
&lt;li&gt;在代码框架不明确时，需要找技术进了确定&lt;/li&gt;
&lt;li&gt;各组技术经理要定期查看代码提交情况，避免出现太多不可控代码&lt;/li&gt;
&lt;/ol&gt;</content:encoded>
      <pubDate>Fri, 22 Sep 2017 14:12:52 GMT</pubDate>
    </item>
    <item>
      <title>#2017-09-17# CentOS自动发邮件</title>
      <link>http://www.oyjie.cn/article/4</link>
      <content:encoded>&lt;h2&gt;应用场景&lt;/h2&gt;
&lt;p&gt;我们组有十几个人，安排了值日倒垃圾的表，但是总是有人会忘记，然后产品经理就将这个东西与个人绩效挂钩，少一次扣一分，这里用我的服务器把值日表里内容对应的人每天定时给他发邮件提醒。&lt;/p&gt;
&lt;h2&gt;配置mail&lt;/h2&gt;
&lt;h3&gt;查看mail是否已安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# mail
-bash: mail: command not found
[root@host ~]# witch mail
-bash: witch: command not found
[root@host ~]# which mail
/usr/bin/which: no mail in (/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;不存在，安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# yum install mail
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;配置mail&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看mail配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [root@host ~]# mail
 No mail for root
 [root@host ~]# which mail
 /bin/mail
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有配置账号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [root@host etc]# vi mail.rc
 // 把这段加进去
 set from=账号 
 set smtp=邮件服务器地址
 set smtp-auth-user=账号 
 set smtp-auth-password=密码 
 set smtp-auth=login
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我用的是网易邮箱，对外的服务器地址有这些&lt;/p&gt;
&lt;p&gt;&lt;img src="/upload/2017/09/54a1qc21nih72ri9es3fm7fmhb.png" alt="网易邮箱服务器信息" /&gt;&lt;/p&gt;
&lt;p&gt;对了，这个密码需要邮箱的授权码，不是登录密码。&lt;/p&gt;
&lt;p&gt;=_= 醉了，我的网易邮箱不能开启stmp服务，改用qq邮箱，stmp服务器是smtp.qq.com。&lt;/p&gt;
&lt;h2&gt;配置sendmail&lt;/h2&gt;
&lt;h3&gt;安装sendmail&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum install -y sendmail
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;配置sendmail&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sendmail -bd –q12h
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;-b：设定Sendmail服务运行于后台。&lt;/li&gt;
&lt;li&gt;-d：指定Sendmail以Daemon（守护进程）方式运行。&lt;/li&gt;
&lt;li&gt;-q：设定当Sendmail无法成功发送邮件时，就将邮件保存在队列里，并指定保存时间。上面的12h表示保留12小时。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，要检测Sendmail服务器是否正常运行，可以使用命令行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/rc.d/init.d/sendmail status
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;配置Senmail的SMTP认证&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/mail/sendmail.mc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;esc,查找&lt;code&gt;/TRUST_AUTH_MECH&lt;/code&gt;，去掉这两行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dnl TRUST_AUTH_MECH(`EXTERNAL DIGEST-MD5 CRAM-MD5 LOGIN PLAIN')dnl
dnl define(`confAUTH_MECHANISMS', `EXTERNAL GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN PLAIN')dnl
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网络访问权限&lt;/h3&gt;
&lt;p&gt;esc，查找&lt;code&gt;/DAEMON_OPTIONS&lt;/code&gt;，改为任意网段可访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DAEMON_OPTIONS(`Port=smtp,Addr=0.0.0.0, Name=MTA')dnl
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;生成配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[root#host ~]#m4 /etc/mail/sendmail.mc &amp;gt; /etc/mail/sendmail.cf
m4:/etc/mail/sendmail.mc:10: cannot open `/usr/share/sendmail-cf/m4/cf.m4': No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要安装sendmail-cf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install sendmail-cf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重启sendmail&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/sendmail restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;测试邮件发送&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# echo '文本内容！' | mail -s &amp;quot;标题&amp;quot; 1460300366@qq.com
smtp-server: 530 Error: A secure connection is requiered(such as ssl).......
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;忽略ssl验证&lt;/h3&gt;
&lt;p&gt;修改添加参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/mail.rc
// 追加
set smtp-use-starttls
set ssl-verify=ignore
set nss-config-dir=/etc/pki/nssdb/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# echo '文本内容！' | mail -s &amp;quot;标题&amp;quot; 1460300366@qq.com
Error in certificate: Peer's certificate issuer is not recognized.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;需要证书&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /root/.certs/
echo -n | openssl s_client -connect smtp.qq.com:465 | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &amp;gt; ~/.certs/qq.crt
certutil -A -n &amp;quot;GeoTrust SSL CA&amp;quot; -t &amp;quot;C,,&amp;quot; -d ~/.certs -i ~/.certs/qq.crt
certutil -A -n &amp;quot;GeoTrust Global CA&amp;quot; -t &amp;quot;C,,&amp;quot; -d ~/.certs -i ~/.certs/qq.crt
certutil -L -d /root/.certs
vi /etc/mail.rc
set nss-config-dir=/root/.certs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host share]# echo '文本内容！' | mail -s &amp;quot;标题&amp;quot; 1460300366@qq.com
Error in certificate: Peer's certificate issuer is not recognized.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然&lt;strong&gt;证书报错&lt;/strong&gt;没有验证，但是我收到了邮件，然后就是内容&lt;strong&gt;中文乱码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;证书报错可以这样解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /root/.certs
certutil -A -n &amp;quot;GeoTrust SSL CA - G3&amp;quot; -t &amp;quot;Pu,Pu,Pu&amp;quot;  -d ./ -i qq.crt 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中文乱码这样解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）查看支持的字符集是否有GBK
[root@host ~]# locale -a
2) 安装英文版默认的字符集配置为：
[root@host ~]# cat /etc/sysconfig/i18n
LANG=&amp;quot;en_US.UTF-8&amp;quot;
SYSFONT=&amp;quot;latarcyrheb-sun16&amp;quot;
3) 修改为中文字符集:
[root@host ~]# vi /etc/sysconfig/i18n
LANG=&amp;quot;zh_CN.GBK&amp;quot;
SUPPORTED=&amp;quot;zh_CN.UTF-8:zh_CN:zh&amp;quot;
SYSFONT=&amp;quot;latarcyrheb-sun16&amp;quot;
4) 执行如下命令或者重启即可生效。
[root@host ~]# source /etc/sysconfig/i18n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/upload/2017/09/rjfutfvbkoi1eokfj375k9d01n.png" alt="发送成功！" /&gt;&lt;/p&gt;
&lt;h2&gt;脚本定时发送&lt;/h2&gt;
&lt;h3&gt;发送邮件的脚本&lt;/h3&gt;
&lt;p&gt;新建一个脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# touch /root/test.sh
[root@host ~]# chmod u+x /root/test.sh
[root@host ~]# vi /root/test.sh

#!/bin/csh
SENDDATE=`date`
echo &amp;quot;定时测试，每天7点&amp;quot; | /bin/mail -s &amp;quot;邮件主题 - $SENDDATE&amp;quot; 1460300366@qq.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;添加定时任务&lt;/h3&gt;
&lt;p&gt;让脚本定时自动运行，这个例子是每天7:00发送邮件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# echo &amp;quot;00 07 * * * root /root/test.sh&amp;quot; &amp;gt;&amp;gt; /etc/crontab
[root@host ~]# echo &amp;gt;&amp;gt; /etc/crontab
[root@host ~]# service crond reload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;明天看下效果，然后就写实际应用脚本。&lt;/p&gt;
&lt;p&gt;经检测执行命令前要加个sh，才能执行脚本，因为我那个开头写错了&lt;code&gt;/bin/csh&lt;/code&gt;，应该是&lt;code&gt;/bin/bash&lt;/code&gt;，否则会报错，不过用sh执行就不用管这个问题，并且也不需要确定有没有授权。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@host ~]# /root/test.sh 
-bash: /root/test.sh: /bin/csh: bad interpreter: 没有那个文件或目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我用每分钟一次的测试还是不行，发现可能是没有设置生效，重启一下服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*/1 * * * * root sh /root/test.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/crond restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/upload/2017/09/5mefa20flmihorekcmjhjeiv88.png" alt="测试结果" /&gt;&lt;/p&gt;</content:encoded>
      <pubDate>Sat, 16 Sep 2017 15:55:12 GMT</pubDate>
    </item>
    <item>
      <title>#2017-09-10# Tale模板框架博客搭建记录</title>
      <link>http://www.oyjie.cn/article/3</link>
      <content:encoded>&lt;h2&gt;@首先你要有&lt;/h2&gt;
&lt;p&gt;服务器（我的是CentOs，在&lt;a href="https://bwh1.net/"&gt;搬瓦工&lt;/a&gt;上买的国外服务器）、电脑、浏览器、WIFI、远程连接工具（我用的是SecureCRT）&lt;/p&gt;
&lt;h2&gt;安装jdk1.8&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 查看可用的jdk
yum search java | grep -i jdk  
	
	ldapjdk-javadoc.x86_64 : Javadoc for ldapjdk
	icedtea-web.x86_64 : Additional Java components for OpenJDK - Java browser
	java-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environment
	java-1.6.0-openjdk-demo.x86_64 : OpenJDK Demos
	java-1.6.0-openjdk-devel.x86_64 : OpenJDK Development Environment
	java-1.6.0-openjdk-javadoc.x86_64 : OpenJDK API Documentation
	java-1.6.0-openjdk-src.x86_64 : OpenJDK Source Bundle
	java-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environment
	java-1.7.0-openjdk-demo.x86_64 : OpenJDK Demos
	java-1.7.0-openjdk-devel.x86_64 : OpenJDK Development Environment
	java-1.7.0-openjdk-javadoc.noarch : OpenJDK API Documentation
	java-1.7.0-openjdk-src.x86_64 : OpenJDK Source Bundle
	java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment
	java-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment with full debug on
	java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos
	java-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos with full debug on
	java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment
	java-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment with
	java-1.8.0-openjdk-headless.x86_64 : OpenJDK Runtime Environment
	java-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with full
	java-1.8.0-openjdk-javadoc.noarch : OpenJDK API Documentation
	java-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK API Documentation for packages
	java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle
	java-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle for packages with
	ldapjdk.x86_64 : The Mozilla LDAP Java SDK

//安装jdk1.8
yum install java-1.8.0-openjdk.x86_64 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;iptables 永久打开新端口&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CentOS/RHEL 7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //tale 默认是9000，我们需要开放9000端口
 sudo firewall-cmd --zone=public --add-port=9000/tcp --permanent
 sudo firewall-cmd --zone=public --add-port=80/tcp --permanent
 sudo firewall-cmd --reload 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS/RHEL 6&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //tale 默认是9000，我们需要开放9000端口
 sudo iptables -I INPUT -p tcp -m tcp --dport 9000 -j ACCEPT
 sudo iptables -I INPUT -p tcp -m tcp --dport 80 -j ACCEPT
 sudo service iptables save 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看打开的端口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /etc/init.d/iptables status
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;nginx 安装配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; wget http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx开启对外映射共享&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 安装源库
 chmod +x nginx-release-centos-6-0.el6.ngx.noarch.rpm 
 // 解压
 rpm -i nginx-release-centos-6-0.el6.ngx.noarch.rpm 
 // 安装nginx
 yum install nginx
 // 启动nginx
 service nginx start
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认nginx配置文件: /etc/nginx/nginx.conf         【nginx主要的配置文件】&lt;/li&gt;
&lt;li&gt;默认nginx的ssl配置文件: /etc/nginx/conf.d/ssl.conf 【配置SSL证书的，也可以并入到nginx.conf 文件里】&lt;/li&gt;
&lt;li&gt;默认nginx的虚拟主机配置文件: /etc/nginx/conf.d/virtual.conf 【如同Apache的虚拟主机配置，也可以并入到nginx.conf文件里】&lt;/li&gt;
&lt;li&gt;默认的web_root文件夹路径: /usr/share/nginx/html 【web目录夹，放置Magento主程序】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将你的 web程序文件夹 放到/usr/share/nginx/html下&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;在线下载安装tale&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 请到nginx的html目录下下载
 sudo wget http://7xls9k.dl1.z0.glb.clouddn.com/tale.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; unzip tale.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 进入tale网站的bin目录下
 cd tale/bin
 // 脚本执行授权
 chmod 755 tale.sh
 // 启动
 sh tale.sh start
 // 默认的启动JVM参数为 -Xms128m -Xmx128m 如果你想修改内存配置可以这样 
 sh tale.sh start &amp;quot;-Xms512m -Xmx512m
 // 关闭博客程序
 sh tale.sh stop
 // 查看日志
 sh tale.sh log
 // 查看启动状态
 sh tale.sh status
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;绑定域名&lt;/h2&gt;
&lt;p&gt;通过 IP:端口号，tale默认是9000，访问可以的话，可以去阿里云或其他网站上买个域名，配置好DNS解析，就可以通过域名访问，9000端口不像80是默认端口，在域名后面带个端口比较难看，可以将tale的端口改为80&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 进入配置文件夹
cd tale/resources
// 修改应用配置文件
vi app.properties
//最加一行
server.port=80
cd tale/bin
// 关闭博客程序
sh tale.sh stop
// 启动
sh tale.sh start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你会发现无法启动，因为80端口被占用了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; com.blade.exception.EmbedServerException: java.net.BindException: Address already in use
        at com.blade.embedd.EmbedJettyServer.startup(EmbedJettyServer.java:170)
        at com.blade.embedd.EmbedJettyServer.startup(EmbedJettyServer.java:74)
        at com.blade.Blade.startNoJoin(Blade.java:499)
        at com.blade.Blade.start(Blade.java:472)
        at com.blade.Blade.start(Blade.java:478)
        at com.tale.Application.main(Application.java:11)
Caused by: java.net.BindException: Address already in use
        at sun.nio.ch.Net.bind0(Native Method)
        at sun.nio.ch.Net.bind(Net.java:433)
        at sun.nio.ch.Net.bind(Net.java:425)
        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)
        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)
        at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:298)
        at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)
        at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:236)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)
        at org.eclipse.jetty.server.Server.doStart(Server.java:431)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)
        at com.blade.embedd.EmbedJettyServer.startup(EmbedJettyServer.java:166)
        ... 5 more
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要修改nginx的默认配置，将nginx端口改成其他的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 修改nginx的默认配置
vi /etc/nginx/conf.d/default.conf
// 将listen改成其他，例如9000
server {
    listen       81;
    server_name  localhost;
    ……
}
// 退出保存，重启nginx
nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在重启tale，就可以了，就是你现在访问的网站 ^_^&lt;/p&gt;</content:encoded>
      <pubDate>Sun, 10 Sep 2017 07:51:40 GMT</pubDate>
    </item>
  </channel>
</rss>

